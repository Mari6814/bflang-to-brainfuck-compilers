%{
    #include "bf.h"
    ListStatement *bisonAST;
%}
%locations
%union {
	std::string *identifier;
	std::string *string;
	int integer;
	Expression *exp;
	Statement *stmt;
	QualifiedName *qualified_identifier;
	VariableType *type;
	ReturnVariableDefinition *return_variable_definition;
	vector<ReturnVariableDefinition*> *return_variable_vector;
	VariableDefinition *var_def;
	vector<VariableDefinition*> *var_def_vector;
	vector<Statement*> *statement_vector;
	std::string *inline_string;
}

%token <identifier> IDENTIFIER
%token <integer> INTEGER
%token <string> STRING

%token FUNCTION WHILE IF ELSE VARIABLE RETURN
%token TYPE STRUCT CLASS
%token INPUT PRINT
%token INLINE
%token EQ NE LE GE
%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN
%token SIZEOF
%token IMPLY

%type <exp> expression
%type <stmt> statement type_statement function_statement
%type <type> type
%type <return_variable_definition> return_variable_definition
%type <return_variable_vector> return_variable_vector
%type <var_def> variable_definition
%type <var_def_vector> variable_definition_vector
%type <qualified_identifier> qualified_identifier
%type <inline_string> inline_string
%type <statement_vector> statement_list program

%left '=' ADD_ASSIGN SUB_ASSIGN
%left ','
%left '+' '-'
%left ':'
%nonassoc '(' ')'
%left '.'
%%

program:
    program type_statement          { $$ = $1; $$->push_back($2); }
    | program function_statement    { $$ = $1; $$->push_back($2); }
    | program ';'                   ;
    |                               { $$ = new vector<Statement*>; bisonAST = new ListStatement($$); }

statement_list:
	statement_list statement    { $$ = $1; if ($2) $$->push_back($2); }
	| 						    { $$ = new vector<Statement*>; }


statement:
	function_statement										{ $$ = $1;}
	| VARIABLE variable_definition_vector ';'  				{ $$ = new VariableStatement($2);}
	| type_statement                                      	{ $$ = $1;}
	| RETURN expression ';'									{ $$ = new ReturnStatement($2);}
	| IF expression statement ELSE statement 				{ $$ = new IfStatement($2, $3, $5);}
	| IF expression statement 								{ $$ = new IfStatement($2, $3, nullptr);}
	| WHILE expression statement 							{ $$ = new WhileStatement($2, $3);}
	| expression ';'   										{ $$ = new ExpressionStatement($1);}
	| INPUT expression ';' 									{ $$ = new IOStatement(IOStatement::IOFunction::IOINPUT, $2);}
	| PRINT expression ';'	    							{ $$ = new IOStatement(IOStatement::IOFunction::IOOUTPUT, $2);}
	| INLINE '{' inline_string '}'							{ $$ = new InlineStatement($3);}
	| '{' statement_list '}'								{ $$ = new ListStatement($2);}
	| ';'                                                   { $$ = new Statement; }

type_statement:
    TYPE IDENTIFIER '=' variable_definition_vector  ';'     { $$ = new TypeStatement($2, $4); }

inline_string:
	inline_string '+' 		{ $$ = $1; *$$ += '+'; }
	| inline_string '-' 	{ $$ = $1; *$$ += '-'; }
	| inline_string '>' 	{ $$ = $1; *$$ += '>'; }
	| inline_string IMPLY	{ $$ = $1; *$$ += "->"; }
	| inline_string '<' 	{ $$ = $1; *$$ += '<'; }
	| inline_string '[' 	{ $$ = $1; *$$ += '['; }
	| inline_string ']' 	{ $$ = $1; *$$ += ']'; }
	| inline_string ',' 	{ $$ = $1; *$$ += ','; }
	| inline_string '.' 	{ $$ = $1; *$$ += '.'; }
	| inline_string '@' 	{ $$ = $1; *$$ += '@'; }
	| inline_string '#' 	{ $$ = $1; *$$ += '#'; }
	|                       { $$ = new string; }

function_statement:
	FUNCTION qualified_identifier variable_definition_vector IMPLY return_variable_vector statement 	{ $$ = new FunctionStatement($2, $3, $5, $6); }
	| FUNCTION qualified_identifier IMPLY return_variable_vector statement 							    { $$ = new FunctionStatement($2, nullptr, $4, $5); }
	| FUNCTION qualified_identifier variable_definition_vector statement 						    { $$ = new FunctionStatement($2, $3, nullptr, $4); }
	| FUNCTION qualified_identifier statement 														{ $$ = new FunctionStatement($2, nullptr, nullptr, $3); }

qualified_identifier:
	qualified_identifier '.' IDENTIFIER 	{ $$ = $1; $$->push_back(*$3); delete $3;}
	| IDENTIFIER 							{ $$ = new QualifiedName; $$->push_back(*$1); delete $1; }

type:
	qualified_identifier '*' INTEGER 		{ $$ = new VariableType(VariableType::FIXED, $3, $1); }
	| qualified_identifier '*' 				{ $$ = new VariableType(VariableType::POINTER, 1, $1); }
	| qualified_identifier 					{ $$ = new VariableType(VariableType::STACK, 1, $1); }

return_variable_definition:
	IDENTIFIER ':' type 					{ $$ = new ReturnVariableDefinition($3, $1); }
    | type                                  {
	                                            static size_t unnamedCount = 0;
	                                            $$ = new ReturnVariableDefinition($1, new string("__ret" + std::to_string(unnamedCount++)));
	                                        }

return_variable_vector:
	return_variable_vector ',' return_variable_definition 	    { $$ = $1; $$->push_back($3); }
	| return_variable_definition 							{ $$ = new vector<ReturnVariableDefinition*>; $$->push_back($1); }

variable_definition:
	IDENTIFIER ':' type 	{ $$ = new VariableDefinition($3, $1); }
	| IDENTIFIER 			{ $$ = new VariableDefinition(nullptr, $1); }

variable_definition_vector:
	variable_definition_vector ',' variable_definition 	{ $$ = $1; $$->push_back($3); }
	| variable_definition 								{ $$ = new vector<VariableDefinition*>; $$->push_back($1); }

expression:
	IDENTIFIER          			{ $$ = new IdentifierExpression($1); }
	| STRING                        { $$ = new StringExpression($1); }
	| INTEGER 						{ $$ = new IntExpression($1); }
	| expression '.' expression		{ $$ = new DotExpression($1, $3); }
	| expression '=' expression		{ $$ = new BinaryOperatorExpression(BinaryOperatorExpression::OP_MOV, $1, $3); }
	| expression '+' expression		{ $$ = new BinaryOperatorExpression(BinaryOperatorExpression::OP_ADD, $1, $3); }
	| expression '-' expression		{ $$ = new BinaryOperatorExpression(BinaryOperatorExpression::OP_SUB, $1, $3); }
	| expression '*' expression		{ $$ = new BinaryOperatorExpression(BinaryOperatorExpression::OP_MUL, $1, $3); }
	| expression '/' expression		{ $$ = new BinaryOperatorExpression(BinaryOperatorExpression::OP_DIV, $1, $3); }
	| expression '(' expression ')' { $$ = new CallExpression($1, $3); }
	| expression '(' ')'            { $$ = new CallExpression($1, nullptr); }
	| expression ',' expression     { $$ = new TupleExpression($1, $3); }
	| '(' expression ')' 			{ $$ = $2; }

%%